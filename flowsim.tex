\documentclass{article}

\flushbottom

\setlength{\parskip}{1ex}

\setlength{\textheight}{220mm}%         {9.5in}
\setlength{\topmargin}{-5mm}%           {-13mm}
%\setlength{\headheight}{0in}
%\setlength{\headsep}{0in}
\setlength{\textwidth}{175mm}%          {189mm}
\setlength{\oddsidemargin}{-0.2in}%     {-0.5in}
\setlength{\columnsep}{4mm}

\renewcommand{\topfraction}{.9}
\renewcommand{\bottomfraction}{.9}
\renewcommand{\textfraction}{.1}
\renewcommand{\floatpagefraction}{.8}
\renewcommand{\dbltopfraction}{.9}
\renewcommand{\dblfloatpagefraction}{.8}
\renewcommand{\floatsep}{0mm}
\renewcommand{\textfloatsep}{4mm}%       {2mm}
\renewcommand{\dbltextfloatsep}{4mm}%    {2mm}

% \renewcommand{\baselinestretch}{1.4}
% \renewcommand{\textfloatsep}{8mm}
% \renewcommand{\dbltextfloatsep}{8mm}


\begin{document}

\newcommand{\NAME}{\item[NAME]}
\newcommand{\SYNOPSIS}{\item[SYNOPSIS]}
\newcommand{\DESCRIPTION}{\item[DESCRIPTION]}
\newcommand{\RETURNVALUES}{\item[RETURN VALUES]}
\newcommand{\RETURNDESC}{\item[DESCRIPTION OF RETURN VALUES]}
\newcommand{\KEYWORDS}{\item[KEYWORDS]}
\newcommand{\SEEALSO}{\item[SEE ALSO]}
\newcommand{\BUGS}{\item[BUGS]}

\newcommand{\man}[2]{\newpage\subsection{#1}\renewcommand{\cmdname}{\cmd{#1}}\begin{description}\NAME #1 --- #2}
\newcommand{\manend}{\end{description}}
\newcommand{\cmd}[1]{\textbf{#1}}
\newcommand{\cmdarg}[1]{\textit{#1}}
\newcommand{\cmdname}{WHERE IS THE COMMAND NAME?}

\title{A User's Guide to Flowsim, a Simulator for Measuring Flow Statistics}

\author{Greg Minshall \\ minshall@ipsilon.com}

\maketitle

\begin{abstract}
Ipsilon is selling IP switches.  The performance of these systems is a
function of the traffic characteristics in the environment in which
they are being used.  As a tool for making predictions about overall
system performance, we have written \emph{flowsim}, a simulator for
reading in packet traces and calculating various statistics on the
traffic in the packet trace.  The simulator is primarily written in C,
for speed, but interfaces to Tcl for allowing policy- and
parameter-specific tailoring in a higher level language.
This paper discusses the general design of flowsim and documents its
usage (primarily for Peter Newman).
\end{abstract}

\section{Introduction}

\section{Basic concepts}
\subsection{Input files}
Flowsim is able to read files created by tcpdump(1) (using the "-w
\emph{file}" option).  It is also able to read 24-byte data recorded
from FIXWEST by K. Claffy and Hans Werner Braun.  Tcpdump files are
known to flowsim as "tcpd" files; 24-byte FIXWEST files are known as
"fix" files.

\subsection{Data types}
Flowsim's basic data types are a \emph{flow type}, a \emph{flow entry},
and a \emph{class}.  A flow type represents a specific set of bits from
an IP header and the first portion (source and destination ports) of a
TCP or UDP header.  A flow type is defined with a string of the form:
\begin{verbatim} aa/bb/cc/dd/ee \end{verbatim}
where each of the aa, bb, etc., are names of fields in the packet
header: ihv, ihl, tos, len, id, foff, ttl, prot, sum, src, dst, sport,
dport.  Flow types are initialized using fsim\_set\_flow\_type;
see~\ref{sec:fsimsetflowtype}.  Flow types are referenced using a
numeric value, based at zero (0).

A flow entry corresponds to a specific flow, i.e., ihv=4, ihl=5,
ttl=27, src=10.1.2.3, dst=10.2.3.4.  Flow entries have certain
attributes associated with them; see
section~\ref{sec:fsimcontinueenumeration} for the list.

A class is a more abstract entity.  Since a flow type is merely a set
of header fields, e.g., protocol, source, and destination, there may be a
distinction between different flows within this flow type.  For
example, it may be the case that in a run of the simulator it is
desirable to keep track of TCP statistics independently of UDP
statistics.  This is the function of classes.  To flowsim, a class is a
set of statistics; see~\ref{sec:fsimclasssummary} for details on the
statistics recorded in a class.  Like flow types, classes are
referenced using a numeric value, based at zero (0).

\emph{Note that the class numbered zero (0) has the special property of
accumulating statistics for packets that don't fall in any other
class.}

Thus, a given flow entry is a member of a flow type and is also a
member of a class.  (The situation is in fact slightly more
complicated, in that flow types are actually split into two levels; we
shall visit this complication shortly.)

There are a small number of flow types and classes available (currently
10 each); there are a large number of flow entries.  In general, one
can count things in a flow entry or in a class.  The decision is
normally based on the order of magnitude of different \emph{things} one
wants to count.  If it is a handfull, counting in classes makes sense;
if it is a large number, then count in flows.
\subsection{Basic operation of flowsim}

The basic flow of flowsim is that a packet trace file (and format) is
selected, certain configuration information is provided by the
user-level code, and
then the input file is read in a series of timesteps.  These
timesteps are known as \emph{bins} because of their relationship to
histogram techniques.

As each packet is read, it is matched against a set of \emph{low level}
flow types, looking for a flow type that is suitable for this packet.
The main restriction is whether the incoming packets has enough bytes
in it to \emph{cover} all the fields refereneced in a given flow type.
More specifically, if a low level flow type includes source or
destination port numbers, an incoming packet will not match this flow
type unless it has at least the first 4 bytes beyond the IP header
included in the packet.\footnote{
Flowsim does \emph{not} deal with fragmented packets in any
sophisticated sense; fragmented packets \emph{will not} be associated
with flow entries whose type includes source or destination port
numbers.}

If no flow type is valid for the incoming packet, its statistics
(packet length, packet received, etc.) are counted in class 0, a
distinguished class.  These class zero statistics include information
about why the packet couldn't be classified elsewhere.  No other
processing is done on packets that couldn't otherwise be associated
with a low level flow type.

After a flow type has been determined, the database of \emph{low level}
flow entries is searched to find a flow entry matching the relevant
fields in the incoming packet.  If no flow entry is found, one is
created.

Creating a flow entry involves several operations, the most interesting
being an \emph{upcall} to user-level code associated with the low level
flow type informing it of the creation event and giving it some control
over subsequent behaviour.  It is this upcall which allows the
user-level code to associate the low-level flow entry with a class as
well as with an upper level flow type and class; see
section~\ref{sec:upcallflowentrycreate} for the details.

Once a low level flow entry has been associated with the incoming
packet, the database of high level flow entries is searched to find a
flow of the appropriate type (where \emph{appropriate type} means the
upper level flow type set in the lower level flow entry).  If this
search is not successful, a new upper level flow entry is created; this
results in the same upcall described above.

At this point, both the low level and upper level flow entries have
been established.  Statistics for both the low level and upper level
flow entries and associated classes are updated.  \emph{You want to
make sure you do \textbf{not} associated both the low level and upper
level flow entries with the same class, or the statistics will be
counted twice!}  Counting the statistics can also trigger yet another
upcall, this time a \emph{packet received} upcall.  Each flow
\emph{type} has a packet received upcall command associated with it.
Each flow entry has a time associated with it that gives a time (in the
time sequence associated by times in the incoming packet trace) to make
the packet received upcall.  As each of the low level and upper level
flow entries is processed, if its associated flow type has a non-null
value for the packet received upcall and its time value is less than
the current packet trace time, the upcall is made to the user-level Tcl
code.  The upcall made informs the user-level code that a packet
arrived after the set time, and gives certain statistics from the flow
entry.  The upcall return value can change the class associated with
the flow entry as well as set a new time value (specified as an offset
from the current time) for receiving a new upcall.

\subsubsection{Upgrading classes}

Right after associating both a lower level and an upper level flow
entry for the flow, a slight anomally occurs.  If the lower level flow
entry has a \emph{parent class} value which is greater than the class
value of the upper level flow entry, the upper level flow entry is
\emph{removed} from its old class and \emph{added} to the class
indicated in the lower level flow entry.  The \emph{purpose} of this
action is to allow an upper level flow entry to be \emph{upraded} by an
arriving packet.

For example, say we decided on a policy (as described
in Peter Newman's Infocom '96 paper~\cite{xxx}) in which flows are
host-to-host and \emph{normally} not switched but \emph{convert} to be
switched upon the arrival of a packet from some set of packets (a TCP
packet or an NFS packet or...).  In this case, we could set one upper
level class to be class number 5 and one to be class number 6.  When
the upcall is made on receipt of, say, a UDP DNS packet, we could
return parent class value of 5 from the upcall routine mentioned above.
And, when a TCP FTP data packet was received, we could return a parent
class value of 6.  Thus, the receipt of a TCP packet would cause an
existing class 5 flow to become a class 6 flow (and thus, presumably,
counted in the \emph{to be switched} statistics, though \emph{this}
association is purely a matter for the user-level code and is not known
to the general simulator).

\section{Commands}
The routines described in this section allow user-provided Tcl code to
control the operation of the simulator.  The routines are described in
this section in \emph{alphabetical} order; refer to
section~\ref{sec:usage} for information on how to tie all this
together.

The following are in flowsim.c:

\clearpage
\man{fsim\_class\_summary} {return class statistics}

\SYNOPSIS \cmdname\ class

\DESCRIPTION

\cmdname\ returns statistics for the class \cmdarg{class}
(specified as a number).  The statistics are returned in a string with
a "name value" format.  I.e., each value is preceded by the name of
that value.  The statistics returned are:
\begin{description}
\item[created] the number of flow entries created into this class
\item[deleted] the number of flow entires deleted from this class
\item[added] the number of flow entires added to this class (from
another class)
\item[removed] the number of flow entries deleted from this class
(being added to another class)
\item[active] the number of flow entries that have seen a packet during
this bin
\item[pkts] the number of packets seen by flow entries in this class
\item[bytes] the number of bytes in those packets
\item[sipg] the smoothed inter-packet arrival time (using, basically,
the Van Jacobson code from Appendix A of his SIGCOMM 88 paper)
\item[fragpkts] the number of packets which ended up in this class
because they were fragmented (normally only non-zero for class 0 statistics)
\item[fragbytes] the number of bytes represented by those packets
\item[toosmallpkts] the number of packets which ended up in this class
because they were too small for the flow of any other class
(normally only non-zero for class 0 statistics)
\item[runtpkts] the number of packets which ended up in this class
because the \emph{captured} length was not large enough for the flow
type of any other class (normally only non-zero for class 0 statistics)
\item[runtbytes] the number of bytes represented by those packets
\item[noportpkts] the number of packets which ended up in this class
because they didn't have port numbers (i.e., the packet protocol was
different from TCP or UDP) and so couldn't fit into the flow type with
any other class (normally only non-zero for class 0 statistics)
\item[noportbytes] the number of bytes represented by those packets
\item[lastrecv] the time (within the time space of the input trace
dataset) the last packet was received for a flow entry associated with
this class
\end{description}

All the values are integers with the exception of "lastrecv", which is
expressed as a floating point number of seconds (maximum accuracy is
microseconds).

\BUGS

Probably the fragpkts, etc., should be retrieved in a separate call.

\manend

\man{fsim\_continue\_enumeration}{enumerate flow entries, returning per-flow-entry statistics}

\SYNOPSIS \cmdname\

\DESCRIPTION

\cmdname\ continues an enumeration started by
\cmd{fsim\_start\_enumeration} (see~\ref{sec:fsimstartenumeration}).
The flow type, class, level, and id for the next flow entry are
returned, along with the statistics associated with that flow entry.

The output is again a string, in "name value" format.  The returned
statistics are:
\begin{description}
\item[created] time flow entry was created
\item[last] time of last packet seen
\item[pkts] number of packets seen
\item[bytes] number bytes represented by those packets
\item[sipg] smoothed inter-packet arrival time for packets in this flow
entry
\end{description}

\manend

\man{fsim\_read\_one\_bin}{run the simulator for one time interval}

\SYNOPSIS \cmdname\ ?binsecs?

\DESCRIPTION

\cmdname\ is called to run the simulator for one time
interval.  The interval of time is specified using the \cmdarg{binsecs}
argument; if this argument is omitted, the most recently passed value
is used.  If binsecs is passed as zero (0), or never passed, the entire
simulation will be run.

The value of \cmdarg{binsecs} divides the trace up into various
\emph{epochs}, known internally as \emph{bin numbers}.  The bin number
at any given point of time is $(currenttime-tracestarttime)/binsecs$
(assuming \cmdarg{binsecs} is not zero).

The effect of \cmdname\ is to read the \emph{next}
packet in the trace file and all the rest of the packets in the trace
file whose bin number is the same as that packet.  A subtle effect of
this is that the previous invocation of \cmdname\ may
have ended at bin number 100 while the current invocation may end with
bin number 150; this means there were no packets during bin numbers
101--149.

\manend

\man{fsim\_set\_fix\_file}{specify the name and format of a trace input file}

\SYNOPSIS \cmdname\ filename

\DESCRIPTION

\cmdname\ directs flowsim to use \cmdarg{filename} as
its input file, and that this is a 24-byte per packet FIX-West data
set.

\SEEALSO

\cmd{fsim\_set\_tcpd\_file}

\manend

\man{fsim\_set\_flow\_type}{set a flow type and associated attributes}

\SYNOPSIS \cmdname\ ?-f flow\_type? ?-n new\_flow\_command? ?-r recv\_command? ?-t timerexpired\_command? flowstring

\DESCRIPTION

\cmdname\ is used to define a new flow type and, optionally, associate
certain attributes with the new flow type.

\cmdarg{flowstring} specifies the flow type as a series of header field
names separated by a slash ("/").  For example, \begin{verbatim}
ihv/ihl/tos/ttl/prot/src/dst\end{verbatim} defines a flow type that
uses the internet header version, internet header length, type of
service, time to live, protocol, source, and address fields.

The current list of header fields supported is:
\begin{description}
\item[ihv] The internet header version number (4 for IPv4, 6 for IPv6).
\item[ihl] The internet header length (in units of 8 octets; 5 for an
IPv4 packet with no IP options).
\item[tos] The type of service field.
\item[len] The length of the packet.
\item[id] The identification field of the IP header.
\item[foff] The fragmentation offset field (including the DF and MF
flags).
\item[ttl] The time to live field.
\item[prot] The protocol field (6 for TCP, 17 for UDP, etc.).
\item[sum] The checksum of the IP header.
\item[src] The IP address of the source.
\item[dst] The IP address of the destination.
\item[sport] The source port in the TCP or UDP header.
\item[dport] The destination port in the TCP or UDP header.
\end{description}

The optional arguments are as follows:

\begin{description}
\item[--f] An integer used to refer to this flow type in the future.
If this is unspecified, flow type 0 is used.
\item[--n] The name of the procedure to receive the flow creation
upcall.  See~\ref{sec:upcallnewflow}.  If
this value is unspecified, no flow creation upcall will be made for
flows created in this flow type.
\item[--r] The name of the procedure to receive the packet reception
upcall.  See~\ref{sec:upcallpktrecvd}.  If this value is unspecified,
no packet reception upcall will be made for packets received for flows
in this flow type.
\item[--t] The name of the procedure to receive the timerexpired upcall.
See~\ref{sec:upcalltimerexpired}.  If this value is unspecified,
no timerexpired upcall will be made for flows in this flow type.
\end{description}

\BUGS

The MF and DF bits should be separate from the foff field.

This \emph{only} works for IPv4; IPv6 is not (yet) supported.

\manend

\man{fsim\_set\_tcpd\_file}{specify tcpdump format input file}

\SYNOPSIS \cmdname\ filename

\DESCRIPTION

\cmdname\ directs flowsim to use \cmdarg{filename} as
its input file, and that this is a file created by tcpdump(1) using the
-w flag.

\SEEALSO

\cmd{fsim\_set\_fix\_file}

\manend

\man{fsim\_start\_enumeration}{intialize an enumeration of flows}

\SYNOPSIS \cmdname\

\DESCRIPTION

\cmdname\ is called to initialize the state before enumerating the flow
entries.

\SEEALSO

\cmd{fsim\_continue\_enumeration}

\manend

\man{fsim\_summary}{retrieve class 0 statistics}

\SYNOPSIS \cmdname\

\DESCRIPTION

\cmdname\ returns the class statistics for class 0, which is the class
into which all otherwise unclassified packets fall.

\BUGS

Probably this should be removed, in favor of
\cmd{fsim\_class\_summary}.

\SEEALSO

\cmd{fsim\_class\_summary}

\manend

The following are in flowsim.tcl:

\man{fsim\_startup}{Tcl startup procedure}

\SYNOPSIS \cmdname\

\DESCRIPTION

\cmdname\ is called during initialization.  Its only effect (currently)
is to set the Tcl variable \emph{tcl\_RcFileName} to the string
\begin{verbatim}\~/.flowsim.tcl\end{verbatim}.  (Note that Tcl only
runs the .flowsim.tcl script only if running interactively, i.e.
if no script file was specified on the flowsim command line.)

\BUGS

There should be a method of invoking flowsim such that all the embedded
Tcl code is printed on standard output.

\manend

The following are in simul.tcl:

\man{fsim\_class\_details}{run the simulator and generate a histogram of
class details}

\SYNOPSIS \cmdname\ fixortcpd filename ?binsecs? ?classifier?
?classifiertype? ?ulflows?

\cmdname\ is a high level entry into the simulator (so high level, in
fact, that it probably should not be considered part of the simulator,
but part of user code).

For the list and definition of the arguments, see \cmd{fsim\_setup}
(\ref{sec:fsimsetup}).

\cmdname\ runs the entire trace, printing out a line of class
statistics at the end of each bin.  Each line has the following format:
\begin{verbatim}
binno pktsrouted bytesrouted pktsswitched bytesswitched
pktsdropped bytesdropped created deleted numflows
\end{verbatim}
(where \emph{created} and \emph{deleted} refer to flows created and
deleted).

\SEEALSO

\cmd{fsim\_flow\_details}

\manend

\man{fsim\_flow\_details}{run the simluator and generate a histogram of
flow details}

\SYNOPSIS \cmdname\ fixortcpd filename ?binsecs? ?classifier?
?classifiertype? ?ulflows?

\cmdname\ is a high level entry into the simulator (so high level, in
fact, that it probably should not be considered to be part of the
simulator, but rather part of the user code).

For an explanation of the arguments, see \cmd{fsim\_class\_details}.

\cmdname\ runs the entire trace file in bins of duration
\cmdarg{binsecs}.  At the end of each bin, it uses
\cmd{fsim\_start\_enumeration} and \cmd{fsim\_continue\_enumeration} to
print out statistics for each flow.

\SEEALSO

\cmd{fsim\_class\_details}
\cmd{fsim\_start\_enumeration}
\cmd{fsim\_continue\_enumeration}

\manend

\man{fsim\_setup}{setup simulator for a run}

\SYNOPSIS \cmdname\ fixortcpd filename ?binsecs? ?classifier?
?classifiertype? ?ulflows?

\cmdname\ is used as an interface to \cmd{fsim\_set\_tcpd\_file} or
\cmd{fsim\_set\_fix\_file} and to \cmd{fsim\_setft}.  It also generates
a few lines of output describing the input file and the binsecs
parameter.

The arguments to \cmdname\ are as follows:
\begin{description}
\item[fixortcpd] Is either "fix" or "tcpd", i.e., the format of the
input file.
\item[filename] The name of the input file.
\item[binsecs] The number of seconds for the time slices in the run.
The default is one (1).  The value zero (0) implies run the entire run
at once.
\item[classifier] The procedure name of the user-level classifier,
i.e., the name of the procedure which will used for the flow creation
upcall when new low level flows are created.  If no classifier is
specified, the internal classifier \cmd{fsim\_classifier} is used
(see~\ref{sec:fsimclassifier}).
\item[classifiertype] In order for the low level flows to be of fine
enough resolution to allow the classifier to distinguish between
packets, classifier type is a flow type specifier
(see~\ref{sec:fsimsetflowtype}) containing all the header fields the
classifier needs access to.  This is a bit confusing.  The point is
that the classifier is called when a new low level flow is created, and
this happens when a packet arrives that doesn't match any currently
existing low level flow.  However, if a packet arrives and \emph{does}
match an existing low level flow, it won't be shown to the classifier.
Thus, the classifier needs to make sure that the low level flows are
of fine enough granularity so that two packets from what the
\emph{classifier} thinks of as \emph{two} flows are not treated by the
low level code as \emph{one} flow.
\item[ulflows]  \cmdarg{ulflows} is a complex data structure (expressed
as a string!) which describes the various upper level flows and the
default behaviour to be associated with those flows.  \cmdarg{ulflows}
is a Tcl array of flow descriptions.  Each flow description is, itself,
an array with components in the following order:
\begin{description}
\item[flowtypespecifier] See~\ref{sec:fsimsetflowtype}.
\item[flowtypereference] The integer used to refer to this flow type.
\item[flowcreation] The flow creation upcall routine.
\item[receive] The packet received upcall routine.
\item[timer] The timer expired upcall routine.
\end{description}
\end{description}

\SEEALSO

\cmd{fsim\_set\_tcpd\_file}
\cmd{fsim\_set\_fix\_file}
\cmd{fsim\_setft}

\manend

\man{fsim\_setft}{set lower level flow types and associated attributes}

\SYNOPSIS \cmdname\ classifier classifiertype ulflows

\DESCRIPTION

\cmdname\ looks at the flows in \cmdarg{ulflows} and the header fields
in \cmdarg{classifiertype} to determine how to set up lower level flows
that are fine grained enough to allow the classifier to do its work.
\cmdname\ then sets up the lower level flow types (1 or 2, depending on
whether the header fields in \cmdarg{ulflows} and in
\cmdarg{classifiertype} include source or destination port numbers).
Each of the lower level flow types is set to use \cmdarg{classifier} as
its flow creation upcall.

\begin{description}
\item[classifier] The procedure name of the user-level classifier,
i.e., the name of the procedure which will used for the flow creation
upcall when new low level flows are created.  If no classifier is
specified, the internal classifier \cmd{fsim\_classifier} is used
(see~\ref{sec:fsimclassifier}).
\item[classifiertype] In order for the low level flows to be of fine
enough resolution to allow the classifier to distinguish between
packets, classifier type is a flow type specifier
(see~\ref{sec:fsimsetflowtype}) containing all the header fields the
classifier needs access to.  This is a bit confusing.  The point is
that the classifier is called when a new low level flow is created, and
this happens when a packet arrives that doesn't match any currently
existing low level flow.  However, if a packet arrives and \emph{does}
match an existing low level flow, it won't be shown to the classifier.
Thus, the classifier needs to make sure that the low level flows are
of fine enough granularity so that two packets from what the
\emph{classifier} thinks of as \emph{two} flows are not treated by the
low level code as \emph{one} flow.
\item[ulflows]  \cmdarg{ulflows} is a complex data structure (expressed
as a string!) which describes the various upper level flows and the
default behaviour to be associated with those flows.  \cmdarg{ulflows}
is a Tcl array of flow descriptions.  Each flow description is, itself,
an array with components in the following order:
\begin{description}
\item[flowtypespecifier] See~\ref{sec:fsimsetflowtype}.
\item[flowtypereference] The integer used to refer to this flow type.
\item[flowcreation] The flow creation upcall routine.
\item[receive] The packet received upcall routine.
\item[timer] The timer expired upcall routine.
\end{description}
\end{description}

There is a default set of upper level flows, which is used if
\cmdarg{ulflows} is not passed (or, is passed as the empty set):
\begin{verbatim}
{
    {   ihv/ihl/tos/ttl/prot/src/dst
	FT_UL_NOPORT
	teho_starttimeout
	-
	teho_deleteflow
    }
    {	ihv/ihl/tos/ttl/prot/src/dst/sport/dport
	FT_UL_PORT
	teho_starttimeout
	-
	teho_deleteflow}
}
\end{verbatim}

\manend

The following are upcalls:

\man{upcall\_flow\_creation}{new flow creation upcall}

\SYNOPSIS \cmdname\ class flowtype flowid

\DESCRIPTION

\cmdname\ is called whenever a flow is created in a flow type that has
this command registered with it.  Note that \cmdname\ is \emph{not}
really the name of a command; as a flow type is created, a specific upcall
routine may be registered to receive notification of flow creation
events in that flow type.

\begin{description}
\item[class] The class index of the class associated with the flow type.
\item[flowtype] The flow type index of the flow type.
\item[flowid] The flow identifier of the new flow being created.  This
is in the form \texttt{name/value/name/value...}, where \texttt{name}
is the name of a header field (see~\ref{sec:fsim_set_flow_type}),
and \texttt{value} is the value of that field.  (The values are printed
out in decimal, dotted decimal, or hexadecimal, depending on the
field.)
\end{description}

\RETURNVALUES class parent\_class parent\_flow\_type ?receive\_time?
?timer\_value?

\RETURNDESC
The return value from this call regulates the attributes of the created
flow entry.  The return value is a string with values in the following
order:

\begin{description}
\item[class] The class index of the newly created flow.
\item[upper\_class] The class index of any parent flow that might be created.
\item[upper\_ftype] The flow type index of any parent flow that might be
created.
\item[recvtime] The number of seconds, expressed as a floating point
number, that must pass before the packet received upcall will be made
for a packet received on this flow.  If this value is returned as zero
(or non-existent), the packet received upcall will never be made.
\item[timervalue] The number of seconds, expressed as a floating point
number, that must pass before the system will call the timer expired
upcall for this flow entry.  If this value is returned as zero
(or non-existent), the timer expired upcall will never be made.
\end{description}

\manend

\man{upcall\_packet\_reception}{packet received upcall}

\SYNOPSIS \cmdname\ class ftype flowid FLOW flowstats
\RETURNVALUES class ?receive\_time?

\DESCRIPTION

This routine, registered on a per-flow-type basis, is called when a
packet has been received on a flow when \cmdarg{receive\_time} seconds
have passed since the previous \cmdname\ or
\cmd{upcall\_flow\_creation} upcall on this flow entry
(\cmdarg{receive\_time} in this sentence refers to, of course, that
value passed in that \emph{previous} invocation).

\begin{description}
\item[class] The class index of the flow entry.
\item[ftype] The flow type index of the flow entry.
\item[flowid] The flow identifier of of the flow entry.
\item[FLOW] The string "FLOW".
\item[flowstats] The flow statistics for the flow entry.
\begin{description}
\item[created] The creation time, in absolute time within the time
space of the input trace file.
\item[last] The time at which the previous packet was received on this
flow, in absolute time.
\item[pkts] The number of packets received on this flow.
\item[bytes] The number of bytes received on this flow.
\item[sipg] The smoothed inter-packet arrival time for this flow
(using, basically,
the Van Jacobson code from Appendix A of his SIGCOMM 88 paper).
\end{description}
\end{description}

The return values allow the upcall routine to change attributes of the
flow entry.

\begin{description}
\item[class]  The new (same) class for the flow entry.
\item[receive\_time] The offset from the current time after which to call
the packet received upcall again.  If this return value is missing or
is returned with a value of zero (0), no more packet received upcalls
will be made for this flow.
\end{description}

\manend

\man{upcall\_timer\_expired}{timer expired upcall}

\SYNOPSIS \cmdname\ class ftype flowid FLOW flowstats
\RETURNVALUES ?command? ?timer\_value?

The system provides the service of making upcalls to \cmdname\
(registered on a per-flow-type basis) on a per flow-entry basis when a
timer value (set on a per-flow-entry basis) has expired.  This timer
queue is run once every second.  \cmdname\ can be used to delete flows.

\begin{description}
\item[class] The class of the flow entry whose timer has expired.
\item[ftype] The flow type index of the flow entry whose timer has
expired.
\item[flowid] The flow identifier of the flow entry whose timer has
expired.
\item[FLOW] The string "FLOW".
\item[flowstats] The flow statistics for the flow entry.
\begin{description}
\item[created] The creation time, in absolute time within the time
space of the input trace file.
\item[last] The time at which the previous packet was received on this
flow, in absolute time.
\item[pkts] The number of packets received on this flow.
\item[bytes] The number of bytes received on this flow.
\item[sipg] The smoothed inter-packet arrival time for this flow
(using, basically,
the Van Jacobson code from Appendix A of his SIGCOMM 88 paper).
\end{description}
\end{description}

The return values allow the upcall routine control over the flow entry.

\begin{description}
\item[command] If set to "DELETE", the flow entry will be deleted.  If
set to "-", or omitted, the flow entry will not be deleted.
\item[timer\_value] The offset from the current time after which to call
the timer expired upcall again.  If omitted or returned as zero (0), no
more timer expired upcalls will be made on this flow again.
\end{description}


\manend
\end{document}
